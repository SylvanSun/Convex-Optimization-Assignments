\documentclass[12pt,letterpaper]{article}
\usepackage{fullpage}
\usepackage[top=2cm, bottom=4.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{amsmath,amsthm,amsfonts,amssymb,amscd}
\usepackage{lastpage}
\usepackage{enumerate}
\usepackage{fancyhdr}
\usepackage{mathrsfs}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{xfrac}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\hypersetup{%
  colorlinks=true,
  linkcolor=blue,
  linkbordercolor={0 0 1}
}
\linespread{1.1}
 
\renewcommand\lstlistingname{Algorithm}
\renewcommand\lstlistlistingname{Algorithms}
\def\lstlistingautorefname{Alg.}

\lstdefinestyle{Python}{
    language        = Python,
    frame           = lines, 
    basicstyle      = \footnotesize,
    keywordstyle    = \color{blue},
    stringstyle     = \color{green},
    commentstyle    = \color{red}\ttfamily
}

\setlength{\parindent}{0.0in}
\setlength{\parskip}{0.05in}

% Edit these as appropriate
\newcommand\course{Algorithms}
\newcommand\hwnumber{3}                
\newcommand\NetIDa{SUN Yilin}          
\newcommand\NetIDb{520030910361}          

\pagestyle{fancyplain}
\headheight 35pt
\lhead{\NetIDa}
\lhead{\NetIDa\\\NetIDb}           
\chead{\textbf{\Large Homework \hwnumber}}
\rhead{\course \\ \today}
\lfoot{}
\cfoot{}
\rfoot{\small\thepage}
\headsep 1.5em

\begin{document}

\section{}
\textbf{Algorithm:}\\
We sort the customers by ascending order of their service time,
then serve the customer with smallest service time each time.\\
\textbf{Proof of Correctness:}\\
The total time can be expressed as 
$$T=\sum_{i=1}^{n}\sum_{j=1}^{i}t_j$$
which is simply
$$T=\sum_{i=1}^{n}(n-i+1)t_i$$
So if the sequence $\{t_1,t_2,t_3,\dots,t_n\}$ is in ascending order, i.e.
$t_1\leq t_2\leq t_3\leq\dots\leq t_n$,
simply by the \textbf{rearrangement inequality} we know such a $T$ is the minimum waiting time
because it is the so-called "inverse product sum".\\
\newline
Below is the proof of rearrangement inequality for completeness of this problem.\\
Denote the two sequence that have already sorted by ascending order by $\{a_i\}$ and $\{b_i\}$.
Let $p_i=\sum_{j=1}^{i}b_j$, $q_i=\sum_{j=1}^{i}b_{k_j}$. It's easy to see $p_i\leq q_i$ for $i\leq n-1$ and $p_n=q_n$.\\
Then 
\begin{align}
    \sum_{i=1}^{n}a_{n-i+1}b_{i}&=\sum_{i=1}^{n-1}a_{i}(p_{n-i+1}-p_{n-i})+a_np_1\\
    &=\sum_{i=1}^{n-1}(a_{n-i+1}-a_{n-i})p_i+a_1p_n\\
    &\leq \sum_{i=1}^{n-1}(a_{n-i+1}-a_{n-i})q_i+a_1q_n\\
    &=\sum_{i=1}^{n}a_{n-i+1}b_{k_i}
\end{align}
Another side of the inequality is not used in our problem, 
so the proof is omitted here.

\newpage
\section{}

\newpage
\section{}
\subsection{}
The idea is pretty straightforward.
Since we only need to determine whether B is reachable from A, 
the gas cost is not to our concern here.
So starting from $A$, we fill up the gas tank as soon as we arrive at a gas station.
Following this method, as long as the two adjacent gas stations are within the distance of our tank capacity $C$,
we can always reach the next station from our current station. \\
Given the inputs, i.e. the distance of these $n$ gas stations, we put them in an array $\boldsymbol{d}$ and sort it by ascending order.
Then we calculate the diffenence between adjacent elements in array $\boldsymbol{d}$.
If any of the diffenences is larger than $C$, 
or if the distance between farthest gas station and $D$ is larger than $C$, then $B$ is not reachable.
If not, then $B$ is reachable.  
\begin{algorithm}
  \caption{Determine Reachable}\label{alg:deterreach}
  \begin{algorithmic}[1]
  \Procedure{Determine Reachable}{$\boldsymbol{d},C,D$}:\Comment{$\boldsymbol{d}=\{d_1,d_2,d_3,\dots,d_n\}$}
  \State Sort $\boldsymbol{d}$ by ascending order
  \If{$D-d_n>C$}
  \State \textbf{return} Not Reachable
  \EndIf
  \State Initialize $i\gets 0$
  \While{$i<n$}
  \State $l\gets d_{i+1}-d_i$
  \If{$l>C$}
  \State \textbf{return} Not Reachable
  \EndIf
  \EndWhile
  \State \textbf{return} Reachable
  \EndProcedure
  \end{algorithmic}
\end{algorithm}\\
\textbf{Proof of Correctness:}\\
The algorithm is correct because, as is described above, 
it always guarantees that the reachability of next station can be determined by the nearest gas station before it.
Thus if all the gas stations are reachable from the previous stations and $D$ is reachable from the farthest station, 
$B$ is reachable from $A$.\\
\textbf{Analysis of Running Time:}\\
The time complexity of the sort procedure at line 2 is $O(n\log n)$.
After we sort the sequence, the while loop will finish with time $O(n)$.
So the total running time is $O(n\log n)$.

\newpage
\subsection{}


\newpage
\section{}
\subsection{}
The idea is to find the leaves and pick all of their parents and delete the vertices that is connected to the parents picked each time,
then repeat the process until there is no more vertices in the original graph. 
If the graph is left with a single root after some iterations of the process,
we also pick the root. 
(If not, the root vertex must have been deleted when we picked one of its children)\\
A detailed algorithm is below:\\ 
\begin{algorithm}
  \caption{1-Minimal Cover}\label{alg:1cover}
  \begin{algorithmic}[1]
  \Procedure{1-Minimal Cover}{$G=(V,E)$}:\Comment{G must be a tree}
  \State Initialize set of vertices $S$, $S$ is empty
  \While {$V$ is not empty}
  \If {$|V|=1$}
  \State $S\gets S\cup V$
  \State \textbf{return} $S$
  \EndIf
  \State $P\gets$ Find parents of all the leaves in $G$\Comment{by DFS procedure}
  \State $S\gets S\cup P$
  \State Update $G$ by deleting neighbourhood of $P$ and $P$ themselves
  \EndWhile
  \State \textbf{return} $S$
  \EndProcedure
  \end{algorithmic}
\end{algorithm}\\
\textbf{Proof of Correctness:}\\
We prove by showing that our choice of vertices is necessary at each iteration 
and is global optimal as well.\\
If $|V|=1$, then our algorithm is trivally true.\\
Suppose at current iteration $|V|>1$, 
we know that an optimal minimal cover set must cover all the leaves in $G$,
and we also know that the leaves can ony be covered by picking themselves or their parents.
But obviously the choice of parents are better than picking the leaves themselves 
because for any pick of parent, 
the parent can cover at least the same set of vertices as its child.
So our choice of parents is indeed necessary at each iteration.\\
The reason why the update process at Line 9 does not violate global optimal is that
once a vertex is covered, 
we do not have to consider it ever again.
So we can immediately delete the vertices that are covered by the parents each iteration
and reduce our problem to a similar one with smaller scale.\\
To sum up, our choice of vertices must be necessary,
so it can generate the minimal cover set of $G$.\\
\textbf{Analysis of Running Time:}\\
Since $|E|=|V|-1$, we can describe the time complexity only by $|V|$.
The time spent by our algorithm that is not constant time only comes from the while loop and the DFS at line 7.
At line 7 the DFS process must visit each vertex and edge at least once,
causing a time complexity of $O(|V|)$ each time.
But note that after each iteration the size of $|V|$ is slightly reduced by the updating process,
in the worst case the updating process only deletes 3 vertices from $V$,
so the worst time complexity is 
$$|V|+(|V|-3)+(|V|-6)+\dots+1$$
which is $O(|V|^2)$.
\subsection{}
The idea is similar to the case with $k=1$ and we only need to make some subtle changes to our algorithm.\\
The first change is that we do not pick the parents of all the leaves.
We still need to find all the leaves, 
but we are going to pick the ancestors which have a path with exactly length $k$ of all those leaves.
And we delete the ancestors that are within distance $k$ of these ancestors picked at each iteration.
The descendants are deleted as well.\\
Another change is that we do not end by picking the only root if it remains in the original graph.
Instead, we pick the root when the depth of remaining sub-tree is smaller or equal to $k$ and end the procedure.
\begin{algorithm}
  \caption{k-Minimal Cover}\label{alg:kcover}
  \begin{algorithmic}[1]
  \Procedure{k-Minimal Cover}{$G=(V,E)$}:\Comment{G must be a tree}
  \State Initialize set of vertices $S$, $S$ is empty
  \While {$V$ is not empty}
  \If {the depth of $G$ is smaller or equal to $k$}
  \State $S\gets S\cup\{r\}$\Comment{$r$ is the root of tree}
  \State \textbf{return} $S$
  \EndIf
  \State $P\gets$ Find ancestors with exactly distance $k$ of all the leaves in $G$
  \State $S\gets S\cup P$
  \State Update $G$ by deleting ancestors and descendants within distance $k$ of $P$ 
  \EndWhile
  \State \textbf{return} $S$
  \EndProcedure
  \end{algorithmic}
\end{algorithm}\\
\textbf{Proof of Correctness:}\\
Similar to our proof with $k=1$, at each itertaion,
our choice of the ancestors is necessary because we still need to cover all the leaves.
And to cover the leaves, finding the ancestors with exactly distance $k$ is the best choice 
because they will cover any vertices if we choose another set of vertices.\\
\textbf{Analysis of Running Time:}\\
Similar to our analysis with $k=1$, now our total time is 
$$|V|+(|V|-2k-1)+(|V|-4k-2)+\dots+1$$
which is $O(\frac{|V|^2}{k})$

\section{}

\end{document}
