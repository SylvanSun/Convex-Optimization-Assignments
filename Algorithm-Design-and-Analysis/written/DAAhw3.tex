\documentclass[12pt,letterpaper]{article}
\usepackage{fullpage}
\usepackage[top=2cm, bottom=4.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{amsmath,amsthm,amsfonts,amssymb,amscd}
\usepackage{lastpage}
\usepackage{enumerate}
\usepackage{fancyhdr}
\usepackage{mathrsfs}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{xfrac}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\hypersetup{%
  colorlinks=true,
  linkcolor=blue,
  linkbordercolor={0 0 1}
}
\linespread{1.1}
 
\renewcommand\lstlistingname{Algorithm}
\renewcommand\lstlistlistingname{Algorithms}
\def\lstlistingautorefname{Alg.}

\lstdefinestyle{Python}{
    language        = Python,
    frame           = lines, 
    basicstyle      = \footnotesize,
    keywordstyle    = \color{blue},
    stringstyle     = \color{green},
    commentstyle    = \color{red}\ttfamily
}

\setlength{\parindent}{0.0in}
\setlength{\parskip}{0.05in}

% Edit these as appropriate
\newcommand\course{Algorithms}
\newcommand\hwnumber{3}                
\newcommand\NetIDa{SUN Yilin}          
\newcommand\NetIDb{520030910361}          

\pagestyle{fancyplain}
\headheight 35pt
\lhead{\NetIDa}
\lhead{\NetIDa\\\NetIDb}           
\chead{\textbf{\Large Homework \hwnumber}}
\rhead{\course \\ \today}
\lfoot{}
\cfoot{}
\rfoot{\small\thepage}
\headsep 1.5em

\begin{document}

\section{}
\textbf{Algorithm:}\\
We sort the customers by ascending order of their service time,
then serve the customer with smallest service time each time.\\
\textbf{Proof of Correctness:}\\
The total time can be expressed as 
$$T=\sum_{i=1}^{n}\sum_{j=1}^{i}t_j$$
which is simply
$$T=\sum_{i=1}^{n}(n-i+1)t_i$$
So if the sequence $\{t_1,t_2,t_3,\dots,t_n\}$ is in ascending order, i.e.
$t_1\leq t_2\leq t_3\leq\dots\leq t_n$,
simply by the \textbf{rearrangement inequality} we know such a $T$ is the minimum waiting time
because it is the so-called "inverse product sum".\\
\newline
Below is the proof of rearrangement inequality for completeness of this problem.\\
Denote the two sequence that have already sorted by ascending order by $\{a_i\}$ and $\{b_i\}$.
Let $p_i=\sum_{j=1}^{i}b_j$, $q_i=\sum_{j=1}^{i}b_{k_j}$. It's easy to see $p_i\leq q_i$ for $i\leq n-1$ and $p_n=q_n$.\\
Then 
\begin{align}
    \sum_{i=1}^{n}a_{n-i+1}b_{i}&=\sum_{i=1}^{n-1}a_{i}(p_{n-i+1}-p_{n-i})+a_np_1\\
    &=\sum_{i=1}^{n-1}(a_{n-i+1}-a_{n-i})p_i+a_1p_n\\
    &\leq \sum_{i=1}^{n-1}(a_{n-i+1}-a_{n-i})q_i+a_1q_n\\
    &=\sum_{i=1}^{n}a_{n-i+1}b_{k_i}
\end{align}
Another side of the inequality is not used in our problem, 
so the proof is omitted here.

\newpage
\section{}
\subsection{}
Prove by contradiction. Suppose there are two maximal independent sets denoted by $A$ and $A'$ with different size,
without loss of generality, assume $|A|<|A'|$.
Then by exchange property $\exists x\in A'\backslash A$ such that $A\cup\{x\}\in\mathcal{I}$.
This means that there exists $A\cup\{x\}\in\mathcal{I}$ and $A\subset A\cup\{x\}$,
which contradicts with the fact that $A$ is a maximal independent set.
So maximal independent sets must have the same size.
\subsection{}
We first prove the hereditary property.\\
Obviously $\mathcal{S}$ is non-empty because at least it contains the empty set.
For any $P\in\mathcal{S}$ and any $Q\subset P$, since $P$ is acyclic, $Q$ cannot be acyclic,
so $Q\in\mathcal{S}$. So $M$ has the hereditary property.\\
\newline
We then prove the exchange property.\\
For any two independent sets $A,B\in\mathcal{S}$, without loss of generality, assume $|A|<|B|$.
We consider the forest $G'$ induced by $A$ in $G$.
Suppose there are $k$ trees in $G'$ and the number of edges of each tree is denoted by $a_i$
then we have 
$$\sum_{i=1}^ka_i=|A|$$
Now we consider the "distribution" of edges in $B$.
Since $B\in\mathcal{S}$, $B$ is acyclic.
Then the maximum number of edges from $B$ connecting vertices in each tree of $G'$ is at most $a_i,i\in[k]$.
But we know $|B|>|A|=\sum_{i=1}^ka_i$, 
which means that there is at least one edge in $B$ connecting one(or two) vertex out of $G'$ or
connecting two different trees in $G'$, and we denote this specific edge by $e$. 
Then we know $A\cup\{e\}$ is not acyclic. 
And since it is acyclic, it is in $\mathcal{S}$. 
So there exists $e\in B\backslash A$ such that $A\cup\{e\}\in\mathcal{S}$.
So $M$ has the exchange property.\\
To sum up, $M$ is a matroid.\\
The maximal sets of this matroid are all the spanning trees of graph $G$.

\subsection{}
Prove by contradiction. Suppose there is no maximal independent set with maximum weight containing $x$,
pick an arbitrary maximal set with maximum weight denoted by $S$ and we will show that we can construct another maximal set $S'$ with maximum weight from $S$.\\
We will start from $S$ and $\{x\}$. Our condition here is that $x\notin S$ and $x$ has the maximum weight.
By exchange property $\exists x_{i_1}\in S$ such that $\{x,x_{i_1}\}\in\mathcal{I}$.
Moreover, we can carry out this process as long as $|S|>|\{x,x_{i_1}\}|$.
By exchange property we carry out this process $|S|-1$ times and get a set 
$$S'=\{x,x_{i_1},x_{i_2},x_{i_3},\dots,x_{i_{|S|-1}}\}$$
$S'$ satisfies that $S'\backslash\{x\}\subset S$, $|S'|=|S|$ and $S'\in\mathcal{I}$.\\
The fact that $|S'|=|S|$ and $S'\in\mathcal{I}$ tells us that $S'$ is a maximal independent set, 
and the fact that $S'\backslash\{x\}\subset S$, $x$ has maximum weight tells us that $w(S')\geq w(S)$.
Since $S$ has maximum weight, $S'$ also has maximum weight. 
So we have constructed a maximal independent set with maximum weight containing $x$,
which is $S'$.

\subsection{}
To use this algorithm we only need to formalize our input.\\
For the MST problem we have a graph $G=(V,E)$ and the matroid is properly defined and proved as shown in problem $2.2$,
which is $M=(E,\mathcal{S})$. 
The weight function $w$ is also defined on $E\to \mathbb{R}_{\geq 0}$ in the MST problem.
We then use $M$ and $w$ as inputs for our algorithm.\\
Then this algorithm will pick the element in $E$ with the largest weight as long as $S\cup \{x\}\in\mathcal{I}$,
which is equivalent to picking an edge with largest weight as long as the edges does not generate a cycle in Kruskal's algorithm.
So after we run this algorithm, we will get a maximal(or minimal) spanning tree.

\subsection{}
We define $\mathcal{S}=\{F\subset U|$vectors in $F$ are linearly independent$\}$.
We now prove $M=\{U,\mathcal{S}\}$ is a matroid and use the algorithm described in problem 2.3 with $M$ and $w$ as input.\\
Firstly, the hereditary property is true because any subset of a set containing vectors that are linearly independent must also be containing independent vectors.\\
As for the  exchange property, we prove by constadiction.\\
For any two independent sets $A,B\in\mathcal{S}$, without loss of generality, assume $|A|<|B|$.
If exchange property does not hold for $A$ and $B$, then since $A$ is linearly independent,
$B$ can be linearly expressed by $A$.
Since $B$ can be linearly expressed by a set of vertors with size smaller than $|B|$,
$B$ itself cannot be linearly independent.
So there exists a vector $x\in B$ where $x\notin A$ and $A\cup\{x\}\in\mathcal{S}$.\\
So $M$ is indeed a matroid. Then as we have stated at the start of this problem,
we can run algorithm in 2.3 with $M$ and $w$ and get such a set of linearly independent vectors $S$ with maximum weight.

\newpage
\section{}
\subsection{}
The idea is pretty straightforward.
Since we only need to determine whether B is reachable from A, 
the gas cost is not to our concern here.
So starting from $A$, we fill up the gas tank as soon as we arrive at a gas station.
Following this method, as long as the two adjacent gas stations are within the distance of our tank capacity $C$,
we can always reach the next station from our current station. \\
Given the inputs, i.e. the distance of these $n$ gas stations, we put them in an array $\boldsymbol{d}$ and sort it by ascending order.
Then we calculate the diffenence between adjacent elements in array $\boldsymbol{d}$.
If any of the diffenences is larger than $C$, 
or if the distance between farthest gas station and $D$ is larger than $C$, then $B$ is not reachable.
If not, then $B$ is reachable.  
\begin{algorithm}
  \caption{Determine Reachable}\label{alg:deterreach}
  \begin{algorithmic}[1]
  \Procedure{Determine Reachable}{$\boldsymbol{d},C,D$}:\Comment{$\boldsymbol{d}=\{d_1,d_2,d_3,\dots,d_n\}$}
  \State Sort $\boldsymbol{d}$ by ascending order
  \If{$D-d_n>C$}
  \State \textbf{return} Not Reachable
  \EndIf
  \State Initialize $i\gets 0$
  \While{$i<n$}
  \State $l\gets d_{i+1}-d_i$
  \If{$l>C$}
  \State \textbf{return} Not Reachable
  \EndIf
  \EndWhile
  \State \textbf{return} Reachable
  \EndProcedure
  \end{algorithmic}
\end{algorithm}\\
\textbf{Proof of Correctness:}\\
The algorithm is correct because, as is described above, 
it always guarantees that the reachability of next station can be determined by the nearest gas station before it.
Thus if all the gas stations are reachable from the previous stations and $D$ is reachable from the farthest station, 
$B$ is reachable from $A$.\\
\textbf{Analysis of Running Time:}\\
The time complexity of the sort procedure at line 2 is $O(n\log n)$.
After we sort the sequence, the while loop will finish with time $O(n)$.
So the total running time is $O(n\log n)$.

\newpage
\subsection{}


\newpage
\section{}
\subsection{}
The idea is to find the leaves and pick all of their parents and delete the vertices that is connected to the parents picked each time,
then repeat the process until there is no more vertices in the original graph. 
If the graph is left with a single root after some iterations of the process,
we also pick the root. 
(If not, the root vertex must have been deleted when we picked one of its children)\\
A detailed algorithm is below:\\ 
\begin{algorithm}
  \caption{1-Minimal Cover}\label{alg:1cover}
  \begin{algorithmic}[1]
  \Procedure{1-Minimal Cover}{$G=(V,E)$}:\Comment{G must be a tree}
  \State Initialize set of vertices $S$, $S$ is empty
  \While {$V$ is not empty}
  \If {$|V|=1$}
  \State $S\gets S\cup V$
  \State \textbf{return} $S$
  \EndIf
  \State $P\gets$ Find parents of all the leaves in $G$\Comment{by DFS procedure}
  \State $S\gets S\cup P$
  \State Update $G$ by deleting neighbourhood of $P$ and $P$ themselves
  \EndWhile
  \State \textbf{return} $S$
  \EndProcedure
  \end{algorithmic}
\end{algorithm}\\
\textbf{Proof of Correctness:}\\
We prove by showing that our choice of vertices is necessary at each iteration 
and is global optimal as well.\\
If $|V|=1$, then our algorithm is trivally true.\\
Suppose at current iteration $|V|>1$, 
we know that an optimal minimal cover set must cover all the leaves in $G$,
and we also know that the leaves can ony be covered by picking themselves or their parents.
But obviously the choice of parents are better than picking the leaves themselves 
because for any pick of parent, 
the parent can cover at least the same set of vertices as its child.
So our choice of parents is indeed necessary at each iteration.\\
The reason why the update process at Line 9 does not violate global optimal is that
once a vertex is covered, 
we do not have to consider it ever again.
So we can immediately delete the vertices that are covered by the parents each iteration
and reduce our problem to a similar one with smaller scale.\\
To sum up, our choice of vertices must be necessary,
so it can generate the minimal cover set of $G$.\\
\textbf{Analysis of Running Time:}\\
Since $|E|=|V|-1$, we can describe the time complexity only by $|V|$.
The time spent by our algorithm that is not constant time only comes from the while loop and the DFS at line 7.
At line 7 the DFS process must visit each vertex and edge at least once,
causing a time complexity of $O(|V|)$ each time.
But note that after each iteration the size of $|V|$ is slightly reduced by the updating process,
in the worst case the updating process only deletes 3 vertices from $V$,
so the worst time complexity is 
$$|V|+(|V|-3)+(|V|-6)+\dots+1$$
which is $O(|V|^2)$.
\subsection{}
The idea is similar to the case with $k=1$ and we only need to make some subtle changes to our algorithm.\\
The first change is that we do not pick the parents of all the leaves.
We still need to find all the leaves, 
but we are going to pick the ancestors which have a path with exactly length $k$ of all those leaves.
And we delete the ancestors that are within distance $k$ of these ancestors picked at each iteration.
The descendants are deleted as well.\\
Another change is that we do not end by picking the only root if it remains in the original graph.
Instead, we pick the root when the depth of remaining sub-tree is smaller or equal to $k$ and end the procedure.
\begin{algorithm}
  \caption{k-Minimal Cover}\label{alg:kcover}
  \begin{algorithmic}[1]
  \Procedure{k-Minimal Cover}{$G=(V,E)$}:\Comment{G must be a tree}
  \State Initialize set of vertices $S$, $S$ is empty
  \While {$V$ is not empty}
  \If {the depth of $G$ is smaller or equal to $k$}
  \State $S\gets S\cup\{r\}$\Comment{$r$ is the root of tree}
  \State \textbf{return} $S$
  \EndIf
  \State $P\gets$ Find ancestors with exactly distance $k$ of all the leaves in $G$
  \State $S\gets S\cup P$
  \State Update $G$ by deleting ancestors and descendants within distance $k$ of $P$ 
  \EndWhile
  \State \textbf{return} $S$
  \EndProcedure
  \end{algorithmic}
\end{algorithm}\\
\textbf{Proof of Correctness:}\\
Similar to our proof with $k=1$, at each itertaion,
our choice of the ancestors is necessary because we still need to cover all the leaves.
And to cover the leaves, finding the ancestors with exactly distance $k$ is the best choice 
because they will cover any vertices if we choose another set of vertices.\\
\textbf{Analysis of Running Time:}\\
Similar to our analysis with $k=1$, now our total time is 
$$|V|+(|V|-2k-1)+(|V|-4k-2)+\dots+1$$
which is $O(\frac{|V|^2}{k})$

\section{Comments}
\subsection{}
About a whole day excluding time spent on sleeping and eating(and loafing perhaps).....
\subsection{}
Actually the most difficult question from my perspective is problem 2 about matroid. I do not think I will be able to work out this problem without the hint. The hint actually reduces the time spent on thinking largely. But I will still give this problem a big $5$.\\
As for problem $3$ and $4$ the algorithm is not that hard to figure out,
what takes time is how to prove the correctness and analyze the running time.
So my recommendation is $4$.\\
Problem 1 is down-right application of rearrangement inequality, so the rating is $2$.
If the proof of rearrangement inequality is not required, the rating can be reduced to $1$.
\subsection{}
No collaborators this time.(Big thanks to the hint.)
\end{document}
