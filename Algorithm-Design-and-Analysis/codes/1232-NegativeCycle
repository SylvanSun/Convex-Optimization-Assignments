#include <iostream>
#include <queue>
#include <vector>

#define MAX_E 5005
#define MAX_V 3005
#define INF 99999999
struct Edge {
	int dst;
	int cost;
};

std::vector<Edge> edge[MAX_V];//the edges from any vertex
int q_count[MAX_V];//count the times of each vertex in the queue, to judge the existence of negative cycle
bool vis[MAX_V];//
std::queue<int> q;
int dist[MAX_V];
int v, e;
void initialize_dist(int src);

int main()
{
	std::cin >> v >> e;
	int x, y, z;
	for (int i = 0;i < e;++i) {
		std::cin >> x >> y >> z;
		Edge tmp;
		tmp.dst = y, tmp.cost = z;
		edge[x].push_back(tmp);
	}
	bool find = false;
	initialize_dist(1);//initialize once for each new vertex that has never been considered
	for (int i = 1;i <= v;++i) {
		if (q_count[i]||(i>1&&dist[i]<INF)) {
			continue;
		}//we want to pick a vertex which has not been considered as source
		q.push(i);
		q_count[i]++;//update the number of q_count each time enqueue happens
		vis[i] = true;
		while (!q.empty()) {
			int cur = q.front();
			q.pop();
			vis[cur] = 0;
			int edgenumber = edge[cur].size();
			for (int j = 0;j < edgenumber;++j) {//for every edge from a single vertex, update the dist
				int currdst = edge[cur][j].dst;
				int currcost = edge[cur][j].cost;
				if (dist[currdst] > dist[cur] + currcost) {
					dist[currdst] = dist[cur] + currcost;
					if (!vis[currdst]) {
						vis[currdst] = 1;
						q_count[currdst]++;
						if (q_count[currdst] >= v) {
							find = true;
							break;
						}
						q.push(currdst);
					}
				}
			}
			if (find) {
				break;
			}
		}
		
	}
	if (find) {
		std::cout << "Yes" << std::endl;
	}
	else {
		std::cout << "No" << std::endl;
	}
	return 0;
}

void initialize_dist(int src) {
	for (int i = 1;i <= v;++i) {
		dist[i] = INF;
	}
	dist[src] = 0;
}
